What happens when you run this
printf/scanf ‚Üí asks for a number, prints it.

malloc/free ‚Üí allocates an array, fills it, prints, then frees it.

assert ‚Üí checks condition; if false, program aborts.

atexit ‚Üí registers cleanup(); runs when exit() is called.

system ‚Üí runs a shell command (ls or dir).

perror/strerror ‚Üí shows error when opening a missing file.

exit(EXIT_SUCCESS) ‚Üí ends program with success code.

abort() ‚Üí ends program immediately, no cleanup.

return 0 ‚Üí ends main normally.




ASSERT : 
What it does: Checks if the expression is true at runtime.

If true ‚Üí program continues normally.

If false ‚Üí prints an error message and calls abort(), which stops the program immediately.

Purpose: Used for debugging and catching logic errors early. It‚Äôs like saying: ‚ÄúThis condition must always be true. If not, something is wrong.‚Äù


FREE : 
Assign (malloc) ‚Üí you get memory from the heap.

Use ‚Üí you store values in that memory.

Release (free) ‚Üí you give memory back to the OS.

Nullify ‚Üí you prevent accidental access to freed memory.

If you skip free, you get a memory leak. If you skip nullify, you risk a dangling pointer (accessing freed memory).


ABORT() : 
abort() = emergency stop, no cleanup.

Inside a function ‚Üí program halts when that function is called.

Inside main ‚Üí program halts right there.

In both cases, nothing after abort() executes.

In C: (DECAY) 

An array is not a pointer by itself, but in most contexts, it automatically converts (decays) to a pointer to its first element.
This happens when you:

Pass an array as a function argument.
Use it in arithmetic or assignment (except sizeof or &).
  
int arr[3] = {10, 20, 30};
int *p = arr;  // arr decays to &arr[0]

------------------------------------------------------------------------------------------------------------------------------

  
const int *p = arr;  // OK
*p = 5;              // ‚ùå error: read-only
p = p + 1;           // ‚úÖ OK: pointer itself can change


int * const p = arr; // OK
*p = 5;              // ‚úÖ OK: modify the value
p = p + 1;           // ‚ùå error: pointer is const


const int * const p = arr; // OK
*p = 5;                    // ‚ùå error
p = p + 1;                 // ‚ùå error


------------------------------------------------------------------------------------------------------------------------------

ARRAY - Pointers : 

int arr[4] ; 
int *a = arr;
now *a = arr[0] 

how to access third element ??

printf("%d",*(a+2))


üìå Key idea: arr[i] is equivalent to *(arr + i)

Pass by ref and pass by values are main .

#include<stdio.h>

void swap( int *a , int *y)
{
    int tmp = *a;
    *a=*y;
    *y=tmp;
}
    
int main()
{
    int a =5  , c=10 ;
    printf("before swap --> % d : %d \n",a,c);
    swap(&a,&c);
     printf("after swap --> % d : %d \n",a,c);
     return 0 ;
}



WHEN AN FUCNTION HAVE POINTER ARGUMENTS 
THEY SHOULD CALL ADDRESS OF THE VAR TO CHANGE IN THE ORIGINAL VAR 
IF NOT ONLY THE LOCAL VAR WILL BE CHANGED NOT THE EXPECTED OR CALLEE VAR 

